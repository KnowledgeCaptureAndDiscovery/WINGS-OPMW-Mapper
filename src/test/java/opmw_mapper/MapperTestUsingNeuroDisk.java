package opmw_mapper;

import java.io.File;
import java.io.IOException;

import org.apache.jena.ontology.OntModel;
import org.apache.jena.riot.RDFLanguages;
import org.junit.Assert;
import org.junit.Test;

import edu.isi.kcap.wings.opmm.FilePublisher;
import edu.isi.kcap.wings.opmm.Mapper;

/**
 * This class contains unit tests for the Mapper class. It tests the
 * serialization of the RDF graph in Turtle format, and validates the resulting
 * model against a set of predefined constraints.
 */
public class MapperTestUsingNeuroDisk {
    /**
     * The following constants are used to name the files that will be generated by
     * the mapper.
     * The files will be stored in the export directory.
     * The files are:
     * - execution.ttl
     * - expandedTemplate.ttl
     * - abstractTemplate.ttl
     * The files are generated by the mapper.
     * The files are validated against a set of predefined constraints.
     * The files are loaded into a model.
     * The model is validated against a set of predefined constraints.
     * The model is validated against a set of optional constraints.
     *
     */
    private static final String EXECUTION_FILENAME = "execution";
    private static final String EXPANDED_TEMPLATE_FILENAME = "expandedTemplate";
    private static final String ABSTRACT_TEMPLATE_FILENAME = "abstractTemplate";
    FilePublisher filePublisher;
    /**
     * Domain: it is wings domain concept and it is used to name the file where the
     * catalog will be stored
     * Catalog: a WINGS catalog is a collection of components and data types that
     * can be used to create workflows.
     */
    String domain;
    String catalogDirectory = "domains";

    /**
     * The following constants are used to configure the mapper.
     *
     * endpointQueryURI: the URI of the endpoint where the queries will be sent
     * endpointPostURI: the URI of the endpoint where the triples will be sent
     * exportUrl: used to generate the URIs of the exported files (base)
     * exportPrefix: used to generate the URIs of the exported files (prefix)
     * {exportUrl}/{exportPrefix}
     */
    String exportPrefix = "export";
    String exportUrl = "https://www.opmw.org/";
    String endpointQueryURI = "https://endpoint.mint.isi.edu/provenance/query";
    String endpointPostURI = "https://endpoint.mint.isi.edu/provenance/data";

    // export directory
    String exportDirectory = "export" + File.separator + domain;

    String componentLibraryFilePath = "src/test/resources/neuro/components.owl";
    String planFilePath = "src/test/resources/neuro/plan.owl";

    public MapperTestUsingNeuroDisk() {
        Utils.mkdir(exportDirectory);
        String webServerDirectory = "tmp/";
        String webServerDomain = "http://localhost";
        this.filePublisher = new FilePublisher(FilePublisher.Type.FILE_SYSTEM, webServerDirectory,
                webServerDomain);
        this.domain = "neuroDisk";
    }

    @Test
    public void mainTestSerializationTurtle() throws IOException {
        String serialization = RDFLanguages.TURTLE.getName();
        String executionFilePath = exportDirectory + File.separator + EXECUTION_FILENAME + ".ttl";
        String expandedTemplateFilePath = exportDirectory + File.separator + EXPANDED_TEMPLATE_FILENAME
                + ".ttl";
        String abstractFilePath = exportDirectory + File.separator + ABSTRACT_TEMPLATE_FILENAME
                + "abstractTemplate.ttl";
        try {
            Mapper.main(domain, exportPrefix, exportUrl, catalogDirectory, componentLibraryFilePath,
                    planFilePath,
                    endpointQueryURI, endpointPostURI, executionFilePath, expandedTemplateFilePath,
                    abstractFilePath,
                    filePublisher, serialization);
        } catch (Exception e) {
            e.printStackTrace();
            Assert.assertTrue(false);
        }
        OntModel m = Utils.loadDirectory(exportDirectory);
        validateModel(m);
    }

    public void validateModel(OntModel m) {
        // execution artifacts
        int problems = Integer
                .parseInt(Utils.getCountOf(Queries.COUNT_ARTIFACTS_WITHOUT_ACCOUNT, m, "countArt"));
        Assert.assertTrue(problems <= 0);
        problems = Integer.parseInt(
                Utils.getCountOf(Queries.COUNT_ARTIFACTS_WITHOUT_LOCATION_OR_VALUE, m, "countArt"));
        Assert.assertTrue(problems <= 0);
        problems = Integer.parseInt(
                Utils.getCountOf(Queries.COUNT_ARTIFACTS_WITHOUT_BINDING_TO_TEMPLATE_ARTIFACT, m,
                        "countArt"));
        Assert.assertTrue(problems <= 0);
        problems = Integer
                .parseInt(Utils.getCountOf(Queries.COUNT_ARTIFACTS_WITHOUT_BINDING_TO_PROCESS, m,
                        "countArt"));
        Assert.assertTrue(problems <= 0);
        // execution processes
        problems = Integer.parseInt(Utils.getCountOf(Queries.COUNT_PROCESSES_WITHOUT_ACCOUNT, m, "countProc"));
        Assert.assertTrue(problems <= 0);
        problems = Integer.parseInt(
                Utils.getCountOf(Queries.COUNT_PROCESSES_NOT_BOUND_TO_ARTIFACT, m, "countProc"));
        Assert.assertTrue(problems <= 0);
        problems = Integer.parseInt(Utils.getCountOf(Queries.COUNT_PROCESSES_WITHOUT_CODE, m, "countProc"));
        Assert.assertTrue(problems <= 0);
        problems = Integer
                .parseInt(Utils.getCountOf(Queries.COUNT_PROCESSES_WITHOUT_CORRECT_TEMPLATE_BINDING, m,
                        "countProc"));
        Assert.assertTrue(problems <= 0);
        problems = Integer.parseInt(Utils.getCountOf(Queries.COUNT_EXECUTIONS_WITHOUT_TEMPLATE, m, "countAcc"));
        Assert.assertTrue(problems <= 0);
        System.out.println("Validating:  ALL EXECUTIONS MUST HAVE AN END TIME, A START TIME AND A STATUS.");
        problems = Integer.parseInt(
                Utils.getCountOf(Queries.COUNT_EXECUTIONS_WITHOUT_TIME_OR_STATUS, m, "countAcc"));
        Assert.assertTrue(problems <= 0);
        // template artifacts
        problems = Integer.parseInt(
                Utils.getCountOf(Queries.COUNT_TEMPL_ARTIFACTS_WITHOUT_TEMPLATE, m, "countArt"));
        Assert.assertTrue(problems <= 0);
        problems = Integer
                .parseInt(Utils.getCountOf(Queries.COUNT_TEMPL_ARTIFACTS_WITHOUT_PROCESS_OPMW, m,
                        "countArt"));
        Assert.assertTrue(problems <= 0);
        problems = Integer
                .parseInt(Utils.getCountOf(Queries.COUNT_TEMPL_ARTIFACTS_WITHOUT_PROCESS_P_PLAN, m,
                        "countArt"));
        Assert.assertTrue(problems <= 0);
        // template processes
        problems = Integer.parseInt(
                Utils.getCountOf(Queries.COUNT_TEMPL_PROCESS_WITHOUT_BINDING_TO_ARTIFACT_OPMW, m,
                        "countProc"));
        Assert.assertTrue(problems <= 0);
        problems = Integer
                .parseInt(Utils.getCountOf(Queries.COUNT_TEMPL_PROCESSES_WITHOUT_TEMPLATE_OPMW, m,
                        "countProc"));
        Assert.assertTrue(problems <= 0);
        System.out.println("Validating: ALL TEMPLATE PROCESSES MUST BELONG TO A TEMPLATE (test in PPlan).");
        problems = Integer
                .parseInt(Utils.getCountOf(Queries.COUNT_TEMPL_PROCESSES_WITHOUT_TEMPLATE_PPLAN, m,
                        "countProc"));
        problems = Integer.parseInt(Utils.getCountOf(Queries.COUNT_UNDECLARED_PROCESSES, m, "countProc"));
        Assert.assertTrue(problems <= 0);
        problems = Integer.parseInt(
                Utils.getCountOf(Queries.COUNT_TEMPL_PROCESS_WITHOUT_BINDING_TO_ARTIFACT_OPMW, m,
                        "countProc"));
        Assert.assertTrue(problems <= 0);
        System.out.println(
                "Validating:  ALL TEMPLATE PROCESSES MUST USE OR GENERATE A TEMPLATE ARTIFACT (test in P-PLAN).");
        problems = Integer.parseInt(
                Utils.getCountOf(Queries.COUNT_TEMPL_PROCESS_WITHOUT_BINDING_TO_ARTIFACT_PPLAN, m,
                        "countProc"));
        Assert.assertTrue(problems <= 0);

        // // expanded template (TO DO)
        // System.out.println("Validating: ALL EXPANDED TEMPLATE PROCESSES SHOULD LINK
        // TO A TEMPLATE.");
        // // TO DO
        // System.out.println(
        // "Validating: ALL EXPANDED TEMPLATE PROCESSES SHOULD BE IMPLEMENTATIONS OF A
        // TEMPLATE PROCESS.");
        // // TO DO
        // System.out.println("Validating: ALL EXPANDED TEMPLATE SHOULD LINK TO A
        // TEMPLATE.");
        // // TO DO
        // System.out.println(
        // "Validating: ALL EXPANDED TEMPLATE VARIABLES SHOULD LINK TO A TEMPLATE
        // VARIABLE THAT BELONG TO A TEMPLATE (AND AND EXECUTION).");
        // // TO DO
        // System.out.println(
        // "Validating: ALL EXPANDED PARAMETER VARIABLES SHOULD LINK TO A PARAMETER
        // VARIABLE THAT BELONG TO A TEMPLATE (AND AND EXECUTION).");
        // // TO DO
        // // the following won't work at the moment
        // System.out.println(
        // "Validating: ALL W3ID COMPONENT CLASSES SHOULD HAVE A LABEL (OTHERWISE THEY
        // ARE NOT CORRECTLY LINKED).");
        // // TO DO
        // // the following won't work at the moment
        // System.out.println(
        // "Validating: ALL W3ID DATA CLASSES SHOULD HAVE A LABEL (OTHERWISE THEY ARE
        // NOT CORRECTLY LINKED).");
        // // TO DO

        // Optional tests not included
        // result+="#TEST"+(++n)+": (OPTIONAL TEST) AN ACCOUNT MAY HAVE A POINTER TO THE
        // ORIGINAL LOG FILE.\n";
        // result+="\t"+isTestFailed(Integer.parseInt(Utils.getCountOf(Queries.COUNT_EXECUTIONS_WITHOUT_LOG_FILE,
        // m, "countAcc")))+"\n";
        // result+="#TEST"+(++n)+": (OPTIONAL TEST) TEMPLATES SHOULD HAVE A VERSION
        // NUMBER.\n";
        // result+="\t"+isTestFailed(Integer.parseInt(Utils.getCountOf(Queries.COUNT_TEMPL_WITHOUT_VERSION_NUMBER,
        // m, "countT")))+"\n";
        // result+="#TEST"+(++n)+": (OPTIONAL TEST) TEMPLATES SHOULD HAVE A POINTER TO
        // THE NATIVE SYSTEM TEMPLATE.\n";
        // result+="\t"+isTestFailed(Integer.parseInt(Utils.getCountOf(Queries.COUNT_TEMPL_WITHOUT_NATIVE_SYS_TEMPL,
        // m, "countT")))+"\n";
    }
}
